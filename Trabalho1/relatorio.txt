Processamento Computacional Da Lingua - Relatorio Trabalho 1

Diogo Fernandes - nº 95000
Jorge Gonçalves - nº 96180

Contribuiçao dos elementos:

A contribuiçao dos elementos foi 50/50, inicialmente partilhamos tarefas/exercicios e depois de concluido todos os exercicios efetuamos 
a revisao em conjunto dos mesmos e correcao de pequenos bugs que indentificamos durante a validacao.

Exercicio 1 

As alineas de "a" a "c" entendemos por criar transducers simples com os nos estipulados (m2mmm, d2dd e d2dddd) para obter os resultados pretendidos, 
na alinea "d" , para a criacao do transducer date2year no formato binario recorremos a funcao fsconcat para concatenar os transducers skip e d2dddd. 
Para a alinea "e" criamos comecamos por criar o transducer dash que verifica se o digito na transicao e um hifen e reutilizamos os transducers criados nas 
alineas anteriores (d2dd e d2dddd), mais uma recorremos a funcao fsconcat para a concatenar os tres transducers descritos e gerar o binario date2norm.

bissexto ....


Exercicio 2

r2a ....


Exercicio 3
Grupo:
    - Diogo Fernandes nº95000
    - Jorge Gonçalves nº96180

Contribuição dos elementos:
    - Diogo: 50%
    - Jorge: 50%
    Pensamos que ambos os elementos contribuíram de igual forma para este trabalho. Realizando praticamente o mesmo número de alíneas e ajudando-se um ao outro. 

Descrição das opções tomadas:
1. 
	a. Nesta primeira alínea procurou-se, em primeiro lugar, separar os meses pelo primeiro dígito e, de seguida mapear o segundo dígito ao mês respetivo.
    b. Na criacao do transducer d2dd a abordagem foi adicionar o zero a esquerda apenas quando temos um caracter caso contrario caso contrario o caminho alternativo
       apenas e aceite caso o input tenha no minimo 2 digitos.
    c. Um pouco mais complexo que o anterior comecamos por desenhar dois caminhos um com apenas 1 digito e outro com pelo menos 4 digitos. A partir desses dois caminhos
       foram derivados os seguintes para pelo menos 2 digitos e 3 digitos.
    d. Para a criacao do transducer date2year criamos um transducer chamado skip que verifica se o caracter esta contido no conjunto {-,0,1,2,3,4,5,6,7,8,9}, 
       este transducer foi utilizado para verificar as 6 primeiras transicoes, para as ultimas quatro transicoes reutilizamos o transducer d2dddd de forma a 
       retornar o ano no formato de 4 digitos. Para a criacao do transducer date2year no formato binario recorremos a funcao fsconcat para concatenar os 
       transducers skip e d2dddd. 
    e. Para a alinea "e" comecamos por criar o transducer dash que verifica se o digito na transicao e um hifen e reutilizamos os transducers criados nas 
       alineas anteriores (d2dd e d2dddd), mais uma vez recorremos a funcao fsconcat para a concatenar os tres transducers descritos e gerar o binario date2norm.
    f. Neste transducer o primeiro objetivo foi pensar como aplicar a regras do ano bissexto:
       - Anos multiplos de 400 sao bissextos
       - Anos multiplos de 4 e nao multiplos de 100 sao bissextos.
       Com essas regras criamos alguns transducers para nos ajudar:
       - bissexto_4multiplesupto99 -> aceita multipos de 4 entre 0 e 99.
       - bissexto_negative4multiplesupto99 -> aceita nao multipos de 4 entre 0 e 99.
       - bissexto_skip -> aceita qualquer digito entre 0 e 9 e retorna epsilon.
       - bissexto_skipdoublezero -> aceita sequecia de dois zeros e retorna epsilon.
       - bissexto_yes/bissexto_no -> retorna yes ou no.
       Apos criacao dos transducers acima decidimos quatro caminhos, que deram origem a mais 4 transducers 
       - Multiplos de 400 -> yes : com recurso a funcao fstconcat e os transducers bissexto_4multiplesupto99, bissexto_skipdoublezero e bissexto_yes
       - Multiplos de 4 excepto os multiples de 100 -> yes : com recurso a funcao fstconcat e os transducers bissexto_skip, bissexto_4multiplesupto99 e bissexto_yes
       - Nao Multiplos de 400 (multiplos de 100 incluidos) -> no : com recurso a funcao fstconcat e os transducers bissexto_negative4multiplesupto99, bissexto_skipdoublezero e bissexto_yes
       - Nao Multiples de 4 -> no : com recurso a funcao fstconcat e os transducers bissexto_skip, bissexto_negative4multiplesupto99 e bissexto_yes
       Por fim com recurso a funcao fstunion criamos o transducer bissexto.
2. 
	a. Para a concepcao do transducer r2a, comecamos por criar quatro transducers um para a ordem dos milhares, outros para ordem das centenas, outro para a ordem das dezenas 
       e por fim um para ordem das unidades. Criamos tambem um transducer para lidar com os epsilon e retornar zero para alguns casos especificos. 
       Apos criacao dos transducers decidimos que deveriamos ter um caminho para cada tamanho de numero, um para os numeros de 4 digitos, outro para os numeros 3 digitos,
       outro para de 2 digitos e finalmente um para o de 1 digito. Para os caminhos que tem mais de um digito com excepcao da primeira transicao todas deveriam lidar com o 
       epsilon e retornar zero, entao criamos mais tres transducer com recurso a funcao fstunion. Recorrendo a funcao fstconcat definimos criamos os binarios para os 4 diferentes
       caminhos e por fim mais uma vez com recurso a funcao fstunion criamos o binario r2a.
	b. Para fazer transducer a2r, utilizando o mesmo raciocinio do exercicio anterior, o primeiro pensamento foi dividir o processamento por cada dígito do número. 
       Em cada um dos 4 tranducers iniciais, cada algarismo vai ser substituído pela letra correspondente à posição à qual o transducer se refere (e.g. a2r_milhares).
       Neste sentido observamos uma combinação de dígitos em cada uma dessas posições que se vão traduzir em números romanos diferentes, ou seja, uma união dos vários 
       tranducers:
            - a2r_milhares + a2r_centenas + a2r_dezenas + a2r_unidades ou
            - a2r_centenas + a2r_dezenas + a2r_unidades ou
            - a2r_dezenas + a2r_unidades
3. Em todas as alíneas do exercício 3 a lógica baseou-se em separar o dia, mês e ano usando o transducer "dash" e usar os transducers previamente criados para modificar 
   ou manter cada uma dessas componentes da data:
    a. Na primeira alínea foi usado o transducer d2dd no dia para apenas manter o dia com dois dígitos, seguido do mm2mmm para transformar o mês para o formato de 
       três letras e, por fim, usou.se o d2dddd para retirar a data.
    b. Na segunda alínea aplicou-se individualmente e a cada componente da data o transducer r2a para converter o numeral árabe em numeral romano.
    c. Na terceira alínea foi necessário incialmente criar um transducer a partir do transducer mm2mmm invertido e do a2r que recebesse um mês em formato de três letras 
       e que retornasse o seu equivalente em numeração romana. Assim, foi possível aplicar este transducer ao mês da data de input e aplicar o a2r ao dia e ao ano.
    d. Com recurso a funcao fstcompose combinamos os transducers date_r2a para conversao de um numero romano para arabico, o transducer date2norm para normalizar o formato 
       da data, date2year para extrair o ano e finalmente o transducer bissexto que retornara o resultado pretendido, yes (se bissexto) ou no (se nao). 
